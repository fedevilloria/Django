Plantillas

Son cadenas de texto que pueden contener material HTML (casi siempre va a pasar) pero no exclusivamente tendra esto, tambien se pueden crear plantillas con cualquier otra herramienta de texto plano.

Sirven para separar la parte logica de la parte visual de un documento web.

Se utilizan de diversas formas, la mas habitual es guardar la cadena de texto en un documento independiente (HTML) y luego cargar ese documento desde la vista.

La ventaja de utilizar esto es que se pueden realizar cambios en el diseño con independencia del codigo de la vista. Por un lado se manipula la logica y por otro el diseño. Otra ventaja es que se puede diversificar el trabajo del proyecto, los programadores unicamente se meten en la parte de la logica y los diseñadores se meten unicamente en la parte de la presentacion o las vistas web. Otra ventaja es que se puede trabajar a la vez en ambas disciplinas.

    Como se usan?
1- Crear el objeto de tipo Template plt=Template(doc_externo.read())

2- Crear el contexto ctx=Context()
    
    Un contexto son los datos adicionales que puede llegar a utilizar ese template.

3- Renderizar el objeto Template documento = plt.render(ctx)

    Hay que pasarle por parametro el contexto aunque este vacio.


    USO DE VARIABLES EN PLANTILLAS
Desde la plantilla se puede utilizar variables que estan referenciadas en las views o en la parte de codigo. Esto es posible trabajando con el contexto.
Al igual que como se puede trabajar con variables simples, tambien se puede utilizar las librerias de python. Para que el diccionario pueda acceder a esa informacion lo que tenemos que hacer es guardar el valor en una variable y luego referenciarla en el diccionario.
    
    Jerarquia u Orden de Llamadas
Esto es cuando ponemos un . lo que hace Django es buscar primero en un Diccionario a ver si el usuario quiere acudir a eso, si esto no corresponde a un elemento en un diccionario, lo que busca es un Atributo o Propiedad correspondiente a una clase, si no corresponde a esto, lo que hace es buscar a un Metodo perteneciente a un objeto y por ultimo se fija en si el . hace referencia a un Indice de Lista.
Entonces el orden interno que sigue Django queda asi:
    1º- Diccionario
    2º- Atributo
    3º- Metodo
    4º- Indice de Lista

Propiedades o Programacion Orientada a Objetos

Cada funcion tiene propiedades, para veer estas propiedades se ehace con el punto (.) despues de la funcion y se despliega el menu contextual, si no lo hace, es porque no se importo la libreria probablemente.

Puedes crear tus propias clases y acceder a propiedades de esas instancias de clases creadas en el futuro.

Cargador de plantilla
Loader: Sirve para hacer referencia a un archivo de forma mas simple.
Para poder utilizarlo hay que primero importarlo, luego le vamos a especificar donde guardariamos nuestras plantillas para que el loader pueda encontrarlas y por ultimo le especificamos la plantilla que vamos a usar en el momento.

Shortcut
Utilizamos el modulo render de la libreria shortcut de Django, esto nos simplifica varias lineas de codigo. Los primeros dos atributos son obligatorios, es decir, siempre lleva como atributo request y luego la plantilla con el nombre propio (return render(request, nombre_plantilla, context)), el tercer argumento es opcional, el contexto a ser un diccionario en este shortcut lo que podemos hacer es directamente pasar el diccionario en vez de la variable del contexto. Con esto nos olvidamos de tener que cargar una plantilla, renderizarla y luego pasarle el contexto, nos ahorra muchas lineas de codigo.

Plantillas incrustadas
Como ya sabemos los sistemas web utilizan mas de un archivo HTML porque por ejemplo para hacer una pagina web y utilizar una barra de navegacion, a esa barra la vamos a tener que usar en las diferentes vistas, entonces para no escribir 20 veces el mismo codigo se hace en un documento externo y luego lo importas dentro del documento que estas trabajando.
Para incrustar una plantilla se debe ir a la posicion donde queremos colocar la plantilla y debemos escribir lo siguiente {% include "nombre_plantilla" %}.
Tambien se suele ver mucho subcarpetas dentro de la carpeta "Plantilla" mas que nada para tener bien organizado lo que vas a utilizar. Pero si utilizamos estas subcarpetas hay que cambiar la configuracion para que Django pueda saber donde buscar las subcarpetas, esto se hace dentro del "include", y queda de la siguiente manera: {% include "subcarpeta/nombre_plantilla" %}.

Herencia de Plantillas
Consiste en crear una plantilla padre en la cual se va a basar el resto de plantillas del sitio web, esta plantilla contendra una estructura la cual el resto de plantillas seguira esa estructura. Practicamente todos los sitios web repiten el mismo patron, la cabecera y la parte inferior (footer) entonces lo que se hace es crear una plantilla padre con la cabecera y el pie, luego a la zona central se le indica que va a ser un contenido o un bloque cambiante. La ventaja de esto es que al repetir plantillas no es necesario repetir tanto codigo, se utiliza muy poco. Para indicarle a Django que estas plantillas van a heredar las caracteristicas del padre se escribe lo siguiente: {% extends "nombre_plantilla_padre" %}. Para que funcione este comando tiene que ser el primero que aparezca en el codigo de las plantillas hijas.
En este caso se suele utilizar a la plantilla padre con el nombre de "base".
Una vez creamos la plantilla padre e hijas lo que tenemos que hacer es registrar la VISTA y luego la URL.

PROYECTO VS APLICACION
Django hace una distincion entre estos dos conceptos, para trabajar con bases de datos hay que saber esta diferencia. Una aplicacion forma parte de un proyecto, el proyecto es aquel que creamos que no tiene dificultad alguna, la dificultad es ponerlo en funcionamiento. Es decir que la aplicacion siempre va a estar dentro del proyecto y un proyecto dependiendo de la complejidad puede tener de ninguna a muchas aplicaciones.

Aplicacion es un paquete o un modulo que realiza una tarea concreta o una suma de tareas concretas.



Bases de datos

Las bases de datos se crean automaticamente con Django porque es el que tiene incorporado pero si hay que crear lo que son las tablas.

Crear tablas
Para crear tablas vamos a utilizar una clase llamada model, esta clase tiene todas las propiedades y herramientas para poder manejar la base de datos, crear tablas, borrar tablas, crear campos, borrar campos, etc. Django no puede trabajar con modelos si no has creado una aplicacion

Dentro del archivo models hay que crear una clase model por cada tabla que necesitemos que tenga la base de datos

Una vez realizadas las tablas hay que agregar la app en el archivo settings, para agregarlo simplemente escribimos el nombre de la app entre comillas y luego la coma y estaria listo.

Ahora para migrar estas tablas a la base de datos lo primero que hay que hacer es decirle a Django que estas tablas existen, para eso utilizamos el comando en la consola que dice lo siguiente: "python manage.py makemigrations". Esto inicia la creacion de los archivos para poder migrarlos a la base de datos, junto con esto nos proporciona un numero de version de las tablas, ese numero lo vamos a utilizar para que estos archivos migren hacia la base de datos, esto lo hacemos con el siguiente comando: "python manage.py sqlmigrate nombre_app numero_version". Una vez terminado esto simplemente pulleamos las tablas con el comando: "python manage.py migrate".

Para pasarle valores a las variables de momento lo vamos a hacer a traves de consola. Lo que hacemos es abrir el shell del proyecto con el siguiente comando: "python manage.py shell". Luego de esto importamos la clase modelo a trabajar, en este caso usamos el modelo de Articulos (from gestionPedidos.models import Articulos). Para poder agregar los valores lo que hacemos es crear una variable temporal y en el interior escribimos los valores: "art=Articulos(nombre="escritorio", seccion="decoracion", precio=90)". Si bien estos cambios todavia no se visualizan hasta que se ejecute el comando de art.save(), seria el nombre de la variable temporal seguido del save(). Todo esto se puede hacer en un unico paso tambien, se escribe el siguiente codigo: "art3 = Articulos.objects.create(nombre="", seccion="", precio=)".

Para actualizar un valor en concreto se utiliza la variable local y le cambiamos el atributo que queremos, por ejemplo, si quiero cambiar el precio hay que escribir "art.precio=95" y luego para actualizarla en la base de datos escribimos "art.save()".

Para borrar un registro de la lista lo que hacemos es obtener el registro y luego borrarlo, para obtenerlo escribimos en una variable local, en este caso seria "art4 = Articulos.objects.get(id=2)" y el id del objeto que queremos borrar, una vez obtenido ese objeto ingresamos el comando "art4.delete()".

Para realizar la consulta de tipo select para verificar los registros que tenemos lo que hacemos es primero guardar en una variable local aquellos registros que estan creados en la base de datos "Lista = Articulos.objects.all()", una vez obtenemos todos los registros para visualizarlos ponemos "Lista.query.__str__()" y nos devuelve aquellos registros existentes en la base de datos.

Como hacer consultas de tipo select con criterios:
Para hacer la consulta con criterios lo que hay que hacer es primero decirle a Django que lo que nos devolvera tiene que ser en cadena de caracteres o str porque sino nos va a devolver una lista unicamente con las posiciones de los articulos seleccionados por el filtro. Para ello hay que crear la funcion __str__ en la seccion de models dentro de la clase que quiero que devuelva, en este caso lo vamos a hacer en articulos, la funcion sera la siguiente: 
    def __str__(self):
        return "El nombre es %s la seccion es %s y el precio es %s" %(self.nombre, self.seccion, self.precio)

con esto ya solucionariamos la salida que nos da los datos especificos. Pero a modo de recuerdo una vez que hacemos cambios en models hay que volver a migrarlas. Una vez la migramos volvemos a intentar el codigo que hicimos en un principio: Articulos.objects.filter(seccion="deportes"). Para utilizar mas de un criterio por consola simplemente hay que agregarle una coma, por ejemplo, Articulos.objects.filter(,nombre="pelota", seccion="deportes") Entonces lo que nos devuelve sera la pelota que pertenezca a la seccion de deportes, en caso que haya una pelota de juguete por ejemplo.
En el caso que querramos filtrar por precios hay que tener cuidado con el shell porque no toma los simbolos > (mayor) y < (menor) como tal, sino que hay que escribir __gte (greater than) y __lte (lesser than) respectivamente y quedaria de la siguiente forma:
    Articulos.objects.filter(seccion="deportes", precio__gte=100) Aca nos devolvera los articulos que valgan mas de 100 en la seccion de deportes.
    
    Articulos.objects.filter(seccion="deportes", precio__lte=100) Aca nos devolvera los articulos que valgan menos de 100 en la seccion de deportes.

Tambien hay una forma de ponerle un rango de precios y esto se hace con __range() y quedaria de la siguiente forma: Articulos.objects.filter(seccion="deportes", precio__range(100, 110)) entonces nos devolvera los articulos que esten dentro de ese rango de precios en la seccion especificada

Podemos ordenar la salida que por defecto lo hara de mayor a menor, esto se hace con la funcion order_by y se utiliza de la siguiente forma: Articulos.objects.filter(precio__gte=50). Aca le estoy pidiendo que me devuelva todos los articulos que su precio sea mayor a 50. Para ordenarlos en la salida se le agrega la funcion antes mencionada: Articulos.objects.filter(precio__gte=50).order_by("precio"). Para ordernarlo de mayor a menor se le agrega el signo - antes del filtro precio y queda asi: Articulos.objects.filter(precio__gte=50).order_by("-precio").



Panel de Administracion

Por defecto Django ya trabaja con un panel de administracion, para acceder a el necesitamos crear un superusuario, para hacerlo ingresamos lo siguiente por consola: python manage.py createsuperuser, una vez enviada esa peticion nos va a pedir una serie de datos, entre ellas la contrasena. Una vez creado el superusuario nos dirigimos a la url del panel.

Para poder controlar el panel de administracion desde la web lo que hay que hacer es importar el model a trabajar.
Dentro del panel de administracion a la hora de crear un cliente u articulo todos los campos por defecto son obligatorios, para poder cambiar esto hay que ir a la pestana models y agregarle los siguientes parametros: blank=True, null=True. Quedaria asi completo: email = models.EmailField(blank=True, null=True). En este caso ya no se hara obligatorio rellenar el campo "email".

Para poder cambiar la vista del campo que queremos ver simplemente agregamos el metodo __str__(), como parametro le pasamos el self y que nos devuelva la variable que querramos con self.variable. Con este metodo solo podemos ver una variable, pero hay otro metodo que nos deja ver mas de dos variables, esta es la clase ModelAdmin, esta clase nos permite hacer modificaciones como administrador en el panel de administracion.



Formularios

Request es enviarle informacion al servidor y decirle que haga algo, este request tiene numerosos metodos y propiedades para operar con el servidor.

Para crear el formulario recordar hacer el input, una vez tenemos el input vamos a tener que marcarle el tipo de metodo ya sea GET o POST, la diferencia entre ellos es que se envia la informacion mediante url o no. Una vez creamos el input es importante resaltar el atributo name, ya que eso es lo que nos va a ayudar a localizar ese campo para luego poder manejar los datos que se ingresen.

Envio de email
Para poder enviar mails con Django lo primero que hay que hacer es buscar un servidor de correo que nos permita utilizar sus parametros para que desde nuestro framework podamos enviar los correos. Estos parametros primero se configuran en el archivo settings.py agregando las siguientes lineas:
    EMAIL_BACKEND='django.core.mail.backends.smtp.EmailBackend'
    EMAIL_HOST = 'smtp.gmail.com'
    EMAIL_USE_TLS = True
    EMAIL_PORT = 587
    EMAIL_HOST_USER = 'mail del host'
    EMAIL_HOST_PASSWORD = 'Serial que nos devuelve gmail al crear la contrasena de aplicacion.'

Una vez configurado Django se procede con las siguientes instrucciones 
from django.core.mail import send_mail
send_mail(
    "Asunto",
    "Mensaje.",
    "from@example.com",
    ["to@example.com"],
    fail_silently=False,
)